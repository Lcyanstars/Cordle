**南京航空航天大学**

《程序设计语言二》课程设计

1.需求分析

Wordle 游戏自 2022 年风靡全球，玩家通过多次尝试逐步猜出正确单词。后来出现了很多变体游戏例如猜成语、猜诗词等都非常有意思。

最近出现了 CS2 Wordle，宝可梦 Wordle 等，系统开局随机生成一个答案，玩家开局猜一个 CS2职业选手名/宝可梦名，系统就会对应地给出猜测与答案匹配的信息。

在这些 Wordle里，往往熟悉游戏的高手能用很少的猜测次数就能精准猜中答案，而新手对着百科查找的过程中也收获了解谜的乐趣和游戏相关知识。

受此启发，我想到可以写一个“代码 Wordle”，利用代码的结构性、逻辑性和许多关键词来构建有趣的谜题，玩家也能从中学习。

在收到一些玩家的认为游戏过难的反馈后，我加入了不同模式并建立了提示机制。

2.程序的主要功能

本系统整体上由若干**功能模块**组成，各模块协同工作完成 CodeWordle 游戏的各项功能。主要模块及其关系如下：

- **用户界面模块：** 包括基于 FLTK 的图形界面（GUI）和备用的控制台界面（UI）。它负责与用户交互，显示游戏信息和接收用户输入。用户通过界面发起游戏、输入猜测、查看结果和统计数据等操作。
- **游戏逻辑模块：** 包括游戏管理类和多种游戏模式类，封装了具体的游戏规则和流程。界面模块在玩家选择模式后创建相应的游戏对象，从代码库获取谜题并控制游戏进行，如处理用户猜测、更新谜题状态、判断胜负等。
- **代码片段管理模块：** 负责游戏谜题的数据存储与处理。它由代码片段类和代码库类组成。代码库模块从存储中随机选取代码文件作为谜题，并提供添加、读取、删除代码片段的功能；代码片段类加载具体代码内容，维护字符遮盖状态，并提供字符匹配和揭示等操作接口。
- **统计数据模块：** 负责记录并提供游戏统计数据。每局游戏结束时，游戏逻辑将结果提交给统计模块，统计模块更新游戏场次、胜率和积分等信息，并将记录保存到文件。用户可通过界面查看总体统计和历史记录列表。

各模块通过清晰的接口交互：启动游戏时，界面模块调用游戏逻辑模块初始化游戏；游戏逻辑模块利用代码库模块获取谜题并使用代码片段模块进行猜测匹配运算；游戏结束后，统计模块记录结果，界面模块更新显示相应信息。整个系统框架如下所述，各部分各司其职又紧密配合，实现完整的游戏功能。

![代码框架](https://s2.loli.net/2025/06/17/xdB4vwSJPctHKVQ.png)

3.模块设计分析

**3.1 用户界面模块**

**图形界面（GUI）：** CodeWordle 的主要交互界面采用 FLTK 图形库实现，界面直观友好。应用启动后显示主窗口，包含以下按钮入口：**Play（开始游戏）**、**Rule（游戏规则）**、**Code（代码库管理）**、**Stats（统计数据）** 和 **Exit（退出）**。用户点击相应按钮进入不同功能窗口：

- **游戏主界面：** 在玩家选择具体模式后弹出。界面上部展示当前谜题的遮盖代码内容和提示信息，下部提供输入框供玩家输入猜测子串，并配有“Guess”（猜测）、“Auto”（自动猜测）和“Give Up”（放弃）按钮用于提交猜测、获取提示和放弃游戏。每次猜测后，界面实时更新显示揭示的代码字符和反馈消息。
- **规则窗口：** 展示游戏玩法的说明，如游戏目标、基本操作和各模式的规则提示等，帮助玩家了解如何进行游戏。
- **代码库窗口：** 提供代码片段资源管理功能。该窗口包含**List**（列出所有代码片段 ID）、**Read**（读取并显示指定代码片段内容）、**Add/Edit**（新增或编辑代码片段）和 **Remove**（删除代码片段）等按钮，以及一个文本显示区域用于输出结果。用户可以方便地查看已有谜题列表，添加新的代码片段作为谜题，或删除不需要的谜题。
- **统计窗口：** 显示游戏统计信息，包括总游戏局数、各模式的游戏次数与胜场、Point 模式总积分和平均积分等汇总数据，以及详细的历史记录列表。历史记录按照时间倒序列出每局游戏的模式、谜题 ID、结果（胜/负或得分）等信息，便于玩家回顾。

**控制台界面（备用）：** 除了图形界面外，系统还实现了一个基于控制台的简单用户界面（UI 类）。控制台界面以文本菜单形式与玩家交互：通过打印菜单选项（Play、Rule、Code、Stats、Exit）并读取用户输入的字母选项来导航功能。游戏流程与 GUI 一致，只是通过终端文本显示代码和提示，玩家输入猜测字符串或指令字符（如E退出、A自动猜测、P显示 ID 等）。该控制台 UI 主要用于调试或在无图形环境下的兼容性运行，在最终应用中默认使用图形界面（main 函数中实例化 GUI 类）。

**3.2 代码片段管理模块**

**代码片段类（CodeSnippet）：** 负责加载和表示单个谜题代码。每个代码片段对应一个存储文件，类内部维护：

- code：存放代码文本的行字符串向量。加载时会将代码文件逐行读入，保存所有字符，包括空格和符号。为方便匹配和猜测，统一起见，将制表符替换为4个空格，并在每行末尾补足一定空格（长度不足3的行会补空格到可容纳长度3的猜测），以确保任何长度>=3的猜测都能在该行尝试匹配。
- state：与code结构平行的二维状态矩阵，记录每个字符的位置当前的揭示状态。使用整数标识状态：0表示**未猜中**(隐藏)，1表示**模糊匹配**，2表示**已揭示**(精确匹配)。初始状态下，所有非空格字符状态为0（隐藏）。

CodeSnippet 提供多种方法支持游戏逻辑：

- loadFromFile()：从文件路径读取代码内容初始化code和state。若文件无法打开则抛出异常。
- getTotalNumber()：统计代码片段中实际字符（非空格字符）的总数量，用于确定游戏允许的最大猜测次数或时间等参数。
- getGuessedNumber()：统计当前已揭示的字符数量（state 标记为2的字符数），用于计算得分等。
- getMasked(char placeholder='@', char fuzzyPlaceholder='#')：生成当前遮盖状态下的代码显示结果。该函数遍历每行每个字符，根据状态决定显示：若字符是空格或已揭示，则保留原字符；若未猜中则以占位符@替代；若属于模糊匹配则以特殊符号#显示（可以修改）。这样，玩家看到的界面将呈现代码的行数、缩进和总体结构，其中未猜出的字符以@覆盖，模糊匹配位置以#标记。
- guess(const std::string& guess)：核心匹配函数，对玩家输入的子串进行匹配检查。因为代码长度不是很长，所以采用朴素的匹配算法，如果需要支持快速匹配可以添加 KMP 算法。函数返回一个2元整数组{exactCount, fuzzyCount}，分别表示精确匹配次数和模糊匹配次数。具体过程如下：先判断猜测长度，少于最小长度3则直接返回{-1,-1}作为错误标志；否则逐行扫描代码：对每行，从头至尾截取与猜测等长的子串：
  - **精确匹配**：如果某段代码子串与猜测字符串完全相同，则将该子串对应的state位置全部标记为2（EXACT_MATCH），表示这些字符被揭露，并将精确匹配计数exactCount加1。可能存在多个不重叠或重叠的精确匹配位置，函数会继续查找整个代码。
  - **模糊匹配**：如果开启了模糊匹配功能（fuzzyAllowed=true），对于每个未精确匹配的子串，计算与猜测的差异：逐字符比对，记录不匹配字符数failmatch和猜测串中非空格字符数count。当failmatch &lt;= 1（至多一处字符不符）且count &gt;= 2（猜测中至少包含2个实际字符）时，判定为找到一个模糊匹配位置，将该位置的fuzzyCount加1，并将尚未揭示的那些字符状态标记为1（FUZZY_MATCH）。这些字符不会显示原文而显示为#，提示玩家此处代码与猜测非常接近但有细微差异。  
        匹配检查完成后返回结果计数数组。游戏逻辑据此判断反馈信息。
- reveal()：用于提供额外提示的函数。它随机挑选当前仍隐藏的一个字符位置，将其状态从隐藏(0)改为已揭示(2)，从而在界面显示出该实际字符。此功能在限定猜次数和限时模式中根据规则定时定次触发，以降低游戏难度，提升游戏趣味。
- check()：检查当前谜题是否全部字符都已揭示（即 state 矩阵中所有非空格字符均为2）。若是则表示玩家已成功猜出整段代码。

**代码库类（CodeRepo）：** 用于管理多个代码片段文件，即游戏的题库。它维护代码片段存储目录路径以及文件列表缓存。主要职责和函数：

- **初始化和刷新：** 构造时指定一个目录路径root，如不存在则自动创建；随后调用refresh()扫描目录下所有以“.txt”扩展名结尾的文件，将其路径缓存到内部列表cacheVec中，并按文件名排序（一般文件名使用代码ID）。
- list()：返回当前代码库中所有代码片段的ID列表（文件名去掉“.txt”的部分）。界面调用该函数获取列表用于显示给用户。
- makePath(const std::string& pid)：内部辅助函数，将代码片段ID拼接上目录和“.txt”后缀构成完整文件路径。
- random()：随机从缓存列表中选取一个代码片段ID返回。游戏开始时调用以选择谜题。如果列表为空则返回空字符串表示无可用谜题。
- loadSnippet(const std::string& pid, bool fuzzy=true)：根据给定ID加载相应代码片段文件，创建一个 CodeSnippet 对象并返回。参数fuzzy决定是否允许模糊匹配功能（由游戏模式设置）；该函数实质上调用 CodeSnippet 类的构造函数读取文件内容，如文件不存在将抛出异常。
- add(const std::string& pid, const std::vector&lt;std::string&gt;& lines)：向代码库中新添一个代码文件。传入代码ID和内容行集合，在存储目录下创建（或覆盖）同名 txt 文件写入内容。成功写入后调用refresh()更新缓存列表。若文件无法创建则抛出异常。通过代码库窗口的 Add/Edit 功能，用户可调用此函数添加新的谜题或编辑已有谜题（使用相同 ID 保存相当于覆盖更新）。
- remove(const std::string& pid)：删除指定 ID 的代码片段文件。调用文件系统删除操作，并刷新列表缓存。返回布尔值表示删除是否成功。供界面 Remove 按钮使用，不存在的 ID 会提醒“未找到”。
- read(const std::string& pid)：读取指定代码文件的原始内容并以单个字符串返回（保留换行格式）。界面在 Code 窗口执行 Read 操作时使用该函数，将内容加载到文本显示区域，方便用户直接查看代码全文。

通过代码片段和代码库模块，系统能够方便地存储、获取和管理游戏谜题数据，实现题库的扩展性和持久化。

**3.3 游戏逻辑模块**

游戏逻辑模块由**Game**基类和三个派生的**游戏模式类**（Limited Guesses、Time Attack、Point）组成，另包含一个辅助的**AutoGuess 自动猜测类**。该模块负责控制每局游戏的流程和规则判定。

**Game 基类：** 抽象封装了一局游戏的通用属性和行为：

- **成员属性：** 包括当前使用的代码库repo引用，当前选择的谜题代码片段snippet对象，统计记录引用stats，当前谜题IDpid，玩家已猜次数guesses计数，以及布尔标志fuzzyAllowed（是否允许模糊匹配）和showPID（是否显示问题ID链接）。这些标志由不同模式初始化设置，用于控制游戏中是否可用模糊提示和是否展示代码片段的题目编号。
- **基本流程方法：**
  - start(): 随机选择谜题并初始化。调用代码库的random()获取随机代码ID赋给pid，若返回空表示题库无题则启动失败；否则调用repo.loadSnippet(pid, fuzzyAllowed)加载代码片段，初始化snippet对象。派生类中可根据需要扩展该函数以设置模式特定的参数（如猜测次数上限或计时器）。
  - makeGuess(const std::string& guess): 处理玩家的一次猜测输入，返回反馈信息字符串列表。在基类实现中，包含对特殊指令的处理和通用猜测流程：
    - 若玩家输入"P"且当前未显示PID，则执行showPID=true并返回提示信息“PID显示已启用”用于告知玩家（Point 模式下可用，用于显示代码来源题号）。
    - 若玩家输入"F"且当前未启用模糊匹配，则执行fuzzyAllowed=true并返回“模糊匹配已启用”，表示接下来猜测可以出现模糊提示（Point 模式下可用）。
    - 否则，将输入字符串传给snippet.guess()进行匹配，得到精确/模糊匹配数量结果。若结果表明输入长度不合法（返回-1），则反馈一条错误信息提示猜测子串至少需要3个字符；若有效，则先将总猜测次数guesses自增1。接下来根据当前模式规则决定是否揭示额外字符：调用revealTimes()计算本次猜测应触发的**自动揭示次数**（例如限次模式每第5次猜测触发一次，限时模式根据时间间隔触发），得到次数后循环调用snippet.reveal()相应次，将若干未揭示字符显示出来帮助玩家。最后，根据匹配结果构造反馈消息：格式为“X matches found.”，如果模糊匹配被启用则追加“, Y fuzzy matches found.”，告知玩家本次猜中多少处子串以及有多少处接近匹配（模糊）。消息以句号结尾并作为字符串列表返回（便于UI统一显示处理）。
  - getGameInfo(): 虚函数，返回当前游戏状态的一些文本信息。基类默认实现仅返回已用猜测次数，如"N guesses"；各子类会重写该函数提供特定于模式的状态信息（例如剩余次数、已用时间或当前积分）。
  - getDisplayLines(): 虚函数，返回用于界面显示的所有行内容。基类提供了通用实现：首先获取getGameInfo()得到状态行，然后如果已允许显示PID则添加一行包含当前问题来源链接（例如“Problem: www.luogu.com.cn/problem/题目ID ”）；接着调用\`snippet.getMasked()\`获取当前谜题的遮盖代码行集合，并逐行附加到结果；最后附加一行通用提示信息：“Enter> your guesses(>= 3 chars), or end the game by entering E, or get an auto guess by entering A”（提示玩家输入猜测、输入E结束或输入A获取提示猜测）。Point 模式会重写该方法以增加特殊指令提示。
  - isFinished(): 判断玩家是否成功解出谜题（即检查 CodeSnippet 的所有字符已揭示），直接调用snippet.check()返回布尔结果。
  - 以上方法定义了每次猜测处理和界面更新的逻辑。除此之外，Game 基类将以下方法声明为纯虚，以强制子类根据规则实现：
    - revealTimes(): 计算当前猜测应进行的自动揭示次数。各模式根据自身规则实现（限次模式每5次猜测返回1，否则0；限时模式根据时间流逝计算；积分模式始终返回0不自动揭示）。
    - isOver(): 判断游戏是否达到失败条件。限次模式判断猜测次数是否用完，限时模式判断是否超时，积分模式则可能永不“失败”（一直可以猜）。
    - saveStatistics(bool isWin): 保存游戏统计数据。不同模式记录的内容不同，例如限次和限时模式记录胜负场数，积分模式记录得分累计等。该函数由Win()或Lose()内部调用，将当前局信息提交给统计模块。
  - Win()和Lose(): 虚函数，返回通用的胜利或失败消息，并调用saveStatistics()更新统计。基类默认给出简洁的“You win!”或“You lose.”字样，子类可根据模式覆盖定制更详细的信息（如用时多少秒、用了多少次猜测等)。

通过 Game 基类与 CodeSnippet、CodeRepo 的组合，游戏逻辑模块能够处理玩家猜测并修改谜题状态，然后将结果反馈给界面模块。下面介绍各具体模式类的特殊实现：

**Guess Limited 模式（猜次数限定模式）:** 玩家有固定次数的猜测机会，要求在耗尽次数前猜出代码。该模式由guessLimitedGame类实现，继承自 Game：

- **初始化：** 在玩家选择此模式时，游戏创建该类实例，构造时将fuzzyAllowed和showPID默认设为true（模糊匹配和显示题号均允许）。调用start()后随机选题并加载snippet。然后计算允许的最大猜测次数maxGuesses：设代码总字符数为 total，根据经验公式max(total/3 + 5, 30)取值（此公式可能过于主观，可以调整），这保证了短代码也有30次猜测机会，长代码则酌情增加次数。
- **游戏过程中：** 每次玩家输入猜测，内部guesses计数加1。revealTimes()实现为：当且仅当猜测次数是5的倍数时返回1，否则返回0。这样每5次猜测后自动揭示一个未露字符，提高玩家猜出答案的机会。isOver()实现为判断guesses >= maxGuesses，即已用猜测数是否达到上限，是则游戏失败。
- **结束判定：** 如果玩家成功猜完（Game基类的isFinished()返回true），则调用Win()返回祝贺消息，例如“You win! You only used X guesses!”告知用了多少次就猜出；如果玩家用完次数仍未猜完代码，isOver()触发失败，Lose()返回“You lose. You have used X guesses.”提示次数耗尽。
- **统计记录：** saveStatistics(bool isWin)实现会将游戏类型标记为“guessLimited”，根据胜负（isWin）更新统计模块中的限次模式游戏场次和胜场计数。每局记录包含时间、模式名“Limited Guesses”、题目ID及“guesses: X/Y Win(或Lose)”的信息，添加到历史记录列表中。

**Time Attack 模式（限时挑战模式）:** 玩家有固定的总时间限制，需要在倒计时结束前猜出代码。由timeAttackGame类实现：

- **初始化：** 构造时默认开启模糊和题号显示（fuzzyAllowed=true, showPID=true）。start()除加载随机谜题外，会设置最大游戏时长maxTime（秒）。maxTime按代码长度大致估计：使用公式max(total/1.5 + 10, 60)，这样较长代码给予更多时间，保证游戏可玩性。启动时还记录startTime为当前时间，并将lastRevealTime初始化为startTime（用于控制定时揭示）。
- **游戏过程中：** 游戏运行同时开始计时。getGameInfo()返回已用时间/总时间，例如“Time: 25s/90s”（注意会在每次猜测后更新，而不是实时更新），通过当前时间与startTime差计算。每次玩家猜测后，revealTimes()根据时间实现自动揭示：计算当前时间与lastRevealTime的差值，除以固定间隔10秒取整得到应揭示的次数，将lastRevealTime往后推进相应的 10 秒倍数。即每累计 10 秒游戏时间就会揭示一个字符（假如玩家一直未猜中，系统也会周期性给提示）。isOver()判断游戏是否超时：通过比较当前时间与startTime，若已超过maxTime秒则游戏失败。
- **结束判定：** 玩家在时间耗尽前猜出代码则胜利。Win()返回“You win! You only used T seconds!”，T 为实际用时秒数；若时间到了仍未全部猜出则失败，Lose()提示“You lose. You have used T seconds.”（即用完了T秒仍未成功）。
- **统计记录：** saveStatistics(bool isWin)实现中，游戏类型标记为“timeAttack”。统计模块中相应增加限时模式游戏总数和胜场计数。历史记录行包含时间、模式名“Time Attack”、谜题ID以及“time: Ts/Tmaxs Win(或Lose)”。其中 T 为实际用秒，Tmax为总秒数。

**Point 模式（积分模式）:** 不限制猜测次数或时间，而是通过积分衡量表现，玩家可以无限猜测直到猜出代码，猜得越快、提示越少则积分越高。由pointGame类实现：

- **初始化：** 构造时默认fuzzyAllowed=false, showPID=false（模糊和题号初始禁用），并设置积分参数默认值：每次猜测罚分guessPenalty=100，积分系数pointFactor=500，奖励系数rewardFactor=1.5。这些参数确保合理的得分计算范围（可在构造时调整）。start()选取谜题后记录总字符数totalNumber用于评分计算。玩家进入游戏时界面会提示可输入特殊命令启用ID显示或模糊匹配，但会减少积分。
- **积分计算：** calcPoint()函数根据当前状态计算玩家积分：公式为  
    其中 guessed 为目前已揭示字符数，guesses 为已猜次数。该公式表示：揭示字符越多积分越高（平方项奖励完整解答），猜测次数越多扣分越多（鼓励少猜）。此外，根据功能启用情况调整：如果玩家启用了题号显示，则乘以showPidPenalty=0.5（积分减半）；启用了模糊匹配则乘以fuzzyPenalty=0.8（积分再打八折），表示使用提示越多，最终得分会降低。若玩家最终猜出了全部代码（guessed == totalNumber），则再乘以奖励系数rewardFactor（>=1，一般为1.5）以嘉奖完全解答。积分实时计算用于显示和最后统计。
- **游戏过程：** Point 模式不设失败条件，因此revealTimes()固定返回0（不会自动揭示），isOver()恒返回false（猜测可以无限继续）。玩家可以一直猜下去直至猜出所有字符。游戏中可随时输入命令P来显示谜题的题目ID（即代码来源，如洛谷题号链接），或F开启模糊匹配辅助，这两者都会降低积分。getGameInfo()每次都会调用calcPoint()更新当前积分并返回如“Points: 1234.5”的字符串；getDisplayLines()在输出状态和代码遮盖内容之外，特别增加了两行说明提醒玩家这些特殊命令：“Enter P to show the problem ID, or F to enable fuzzy match（The game will be easier, but you will get LESS points）”，然后提示猜测输入方式。这些指令行帮助玩家平衡是否使用提示功能。
- **结束判定：** 由于该模式无强制结束，玩家输入E表示主动结束游戏。如果玩家已猜出所有代码，则通过Win()处理胜利，否则即便中途放弃（可能仍有部分字符未猜），系统也按照**结算分数**处理——Point 模式没有严格的“失败”，哪怕积分为负也不会“游戏结束失败”，所以Lose()直接调用Win()逻辑。Win()先调用calcPoint()确认最终积分，然后返回信息如“You achieved X points!”显示玩家本局获得的积分数。
- **统计记录：** saveStatistics(bool isWin)在 Point 模式下忽略 isWin 区分，都算作一局完成，只是将最终积分传递给统计模块。统计数据中，会增加 point 模式游戏次数计数，并将本局积分累加到总积分。历史记录行包含时间、模式名“Point”、题目ID和“points: X Win”字样（为了格式统一标注Win，但实际上Point模式不区分胜负）。统计窗口会展示累计进行的 Point 模式局数，以及平均每局积分和总积分。

**自动猜测提示（AutoGuess）:** 游戏逻辑模块还包括一个独立的AutoGuess类，用于在玩家请求提示时给出猜测建议。AutoGuess 内部预置了一份**常见代码片段子串列表**（长度为3的短字符串），涵盖典型的关键字或代码片段，例如："int", "for", "if(", "els", "ret", "cla" 等等，涵盖C++代码中常见的关键词、操作符片段、格式符等共数十项。算法会按照此列表顺序依次提供猜测建议，并避免重复：

- guess(const std::vector&lt;std::string&gt;& mask): 传入当前谜题遮盖状态（即 CodeSnippet 的getMasked()结果），返回一个推荐猜测字符串。内部维护索引count指向下一个待尝试的关键字。对于当前索引对应的子串，算法扫描当前遮盖代码的每一行，查看该子串是否已经**完全可见**于当前谜题（即 mask 中存在该子串，说明这些字符都已揭晓）。如果已可见，则说明猜它不会有新收获，标记visited=true。然后将count加1移至下一个子串，递归重复上述检查，直到找到一个尚未出现在谜题中的关键字，返回它作为建议。如果所有预定义子串都已尝试过（count 达到列表末尾），则改用random()生成一个随机字符串返回。
- random(): 随机生成一个长度为3的字符串。字符从alphabet_中等概率选取，alphabet 包含了字母、数字及常见代码符号（如括号、运算符等），例如可能生成“x7}”这样的组合。随机猜测虽未必命中，但提供了多样性。

AutoGuess 提示策略是：优先猜测典型代码模式，提高猜中代码关键结构的概率；如果这些都无效果再随机碰运气。比如当前谜题代码是 C++ 的常见结构，AutoGuess 很可能首先提示“int”、“for”等，加快玩家揭开代码的速度。该功能通过界面模块触发，玩家点击“Auto”按钮时系统调用 autoGuesser.guess(mask) 获取建议，将建议字符串显示给玩家供其决定是否使用。（原先设想实现基于信息熵的算法，因为比较难放弃）

**3.4 统计模块**

统计模块由StatisticsRepo类实现，负责保存和提供游戏的统计数据。它在程序运行期间累积数据，并在程序退出或返回主菜单时将数据保存到文件，以便下次运行时继续累积。主要内容包括：总游戏局数、各模式游戏次数及胜率、Point 模式总积分和平均分，以及完整的历史记录列表。设计要点如下：

- **数据存储：** 统计信息保存于一个二进制文件（如“Statistics.dat”）。文件开头依次存储若干固定大小的数值：totalGames（总局数）、guessLimitedGames及guessLimitedWins、timeAttackGames及timeAttackWins、pointGames（积分模式游戏数）和totalPoints（积分模式累计得分）。随后文件其余部分以文本形式保存历史记录，每局一行。这种设计兼顾了数值统计的精确保存和读取（使用固定二进制块）以及历史记录的可变长保存。
- **初始化：** StatisticsRepo 构造时传入统计文件路径。如文件不存在则先创建空文件并写入初始0值，然后调用loadFromFile()读入数据。读取时按前述格式依次提取计数和累计值，并将余下每行记录读入gameHistory列表（vector&lt;string&gt;）。
- **更新与保存：** 提供addGame(const std::string& gameHistoryLine, const std::string& gameType, T state)模板函数用于添加一局游戏记录。其中 gameType 表示模式类别（"guessLimited"、"timeAttack" 或 "point"），state 参数表示状态数据：对于限次和限时模式传入1或0表示胜负，积分模式传入本局得分(double)。函数内部根据类型更新对应计数：
  - 若gameType是猜次数模式，则guessLimitedGames++总数加一，guessLimitedWins += state增加胜场（state为1则加一，为0不变）。
  - 若是限时模式，timeAttackGames++，timeAttackWins += state（同理计算胜场）。
  - 若是积分模式，pointGames++，同时将传入的积分累加到totalPoints。积分模式不存胜负概念，totalPoints用于后续计算平均分。  
        无论哪种模式，totalGames++总局数都递增，并把格式化好的gameHistoryLine追加到历史记录列表。
- **查询显示：** getStatistics()生成当前统计数据的汇总文本列表，供界面显示。它按顺序加入：
  - 总游戏次数，例如“Total Games: 10”。
  - 限次模式成绩：“Guess Limited Games: X/Y”，X为赢的场数，Y为总场数；
  - 限时模式成绩：“Time Attack Games: X/Y”；
  - 积分模式次数：“Point Games: N”（N局，由于无胜负，这里只显示局数）；
  - 平均积分：“Average Points: P”，计算为 totalPoints/pointGames，若无积分局则为0；
  - 总积分：“Total Points: S”，累计所有积分模式游戏的得分总和。  
        然后再加入一行分隔线“==========Game History==========”，接下来逐行附加历史记录列表中各局的字符串（按时间降序排列最近的在上）。历史记录每行内容通过 GameHistoryFormatter 格式化生成，固定宽度对齐包含：时间（年月日时分秒）、游戏模式名称、题目ID、以及游戏详情（猜了X次Win等或积分）。

统计模块确保玩家可以在**Stats**窗口清楚了解自己的游戏情况：包括总体的成功率以及在积分模式下大致的平均表现，同时完整记录了每次挑战的信息，方便分析总结。该模块在每局结束时由游戏逻辑调用更新，并在游戏返回主菜单或退出时通过saveToFile()将最新数据写回文件，保证数据持久化。

4.函数说明

下面列出主要类及其关键函数，并简述其功能：

- **CodeSnippet 类：**
  - CodeSnippet(const fs::path& filePath, bool fuzzy=true): 构造函数，打开指定路径的代码文件读取内容，初始化代码行code和状态矩阵state；fuzzy参数决定是否允许模糊匹配（影响随后的猜测处理）。
  - loadFromFile(): 从当前path指向的文件流读取代码文本行，进行制表符替换和末尾补空格等处理，填充code和state。
  - getTotalNumber(): 计算代码中非空格字符总数。遍历所有行，对每个字符如果不是空格则计数。
  - getGuessedNumber(): 计算当前已猜出的字符数量。遍历所有行，统计state为 EXACT_MATCH(2) 的字符个数。
  - reveal(): 随机揭示一个尚未猜出的字符。实现上先收集所有state不为 EXACT_MATCH 的字符位置到数组，然后随机选取一项，将对应位置的state置为 EXACT_MATCH，使该字符从隐藏变为可见。
  - guess(const std::string& guess): 核心匹配函数，详见前文“模糊匹配算法”。返回{精确匹配次数, 模糊匹配次数}，并直接更新相应state状态（把猜中的字符标记揭示，把符合模糊条件的标记模糊）。玩家每次猜测都会调用此函数。
  - check(): 检查谜题是否全部字符已揭示，若是则返回 true 表示游戏完成。
  - getMasked(char placeholder='@', char fuzzyPlaceholder='#'): 生成当前状态下用于显示的遮盖代码文本。将每个未揭示字符替换为@，模糊匹配字符替换为#，空格和已揭示字符原样保留，返回所有行的字符串向量。
- **CodeRepo 类：**
  - CodeRepo(const fs::path& dir): 构造函数，指定谜题存储目录路径root，如目录不存在则创建，然后调用refresh()加载初始文件列表。
  - refresh(): 扫描root目录，收集所有扩展名“.txt”的文件路径到cacheVec列表，并按文件名排序。每次增删文件后调用以更新缓存。
  - list(): 返回当前题库中所有代码片段ID列表（string 向量）。
  - random(): 随机返回一个代码片段ID字符串。利用随机数生成器在cacheVec列表中抽取一个文件路径返回其无扩展名的部分。若列表为空则返回空字符串。
  - makePath(const std::string& pid): 将给定代码ID转为完整路径（目录 + pid + “.txt”）。
  - loadSnippet(const std::string& pid, bool fuzzy=true): 创建并返回一个 CodeSnippet 对象，用对应ID的文件初始化它（内部调用 CodeSnippet 构造函数）。
  - add(const std::string& pid, const std::vector&lt;std::string&gt;& lines): 新增/更新一个代码片段文件。将给定内容行写入以 pid 命名的 txt 文件，写入每行末尾加换行符。完成后刷新列表。
  - remove(const std::string& pid): 删除 pid.txt 文件，成功则刷新列表。返回 true 表示找到了文件并已删除，false 表示文件不存在。
  - read(const std::string& pid): 读取 pid.txt 文件的全文内容，返回单个字符串（保留原格式换行）。用于在界面上直接显示代码内容给用户查看。
- **StatisticsRepo 类：**
  - StatisticsRepo(const fs::path& filePath): 构造函数，指定统计数据文件路径。若文件不存在则创建初始化，再调用loadFromFile()加载数据。
  - loadFromFile(): 打开文件读取统计计数数据和历史记录。按预定义顺序读取总场数、各模式场数和胜场、累计积分等二进制数据，然后按行读取剩余的历史记录字符串存入gameHistory列表。
  - saveToFile(): 将当前统计数据写回文件保存。先以二进制方式写入计数部分，再逐行写入文本格式的历史记录（每行末尾换行）。
  - addGame(const std::string& gameHistoryLine, const std::string& gameType, T state): 模板函数，添加一局游戏记录并更新统计计数。根据 gameType 类型判断：若为 "guessLimited" 增加限次模式场次并累加胜场(state=1)；"timeAttack" 则增加限时模式场次和胜场；"point" 则增加积分模式场次并将 state（本局得分）加到 totalPoints。然后 totalGames++，将传入的 gameHistoryLine 添加到 gameHistory 列表尾部。
  - getStatistics(): 生成当前统计数据的报告文本。按顺序将总场数、各模式统计（胜场/总场或积分）、平均积分、总积分等信息格式化为字符串放入结果列表，然后添加分隔线和历史记录（按时间逆序）。界面显示统计时调用此方法获取内容。
- **Game 类（抽象基类）：**
  - Game(const CodeRepo& repo, StatisticsRepo& stats, bool fuzzy, bool show): 构造函数，接收代码库和统计模块引用，并根据参数设置当前游戏是否允许模糊匹配、是否显示题号。初始化时猜测计数为0。
  - start(): 虚函数，默认实现从代码库随机选取谜题并加载 CodeSnippet。返回 false 则表示题库为空无法开始。限次和限时模式会重写该函数以设置各自规则参数（猜测上限或计时）。
  - makeGuess(const std::string& guess): 处理一次玩家猜测，返回反馈消息列表。详见前文**Game基类**的猜测处理流程，包括特殊指令检查、调用 CodeSnippet 匹配、增加猜测计数、自动揭示以及结果消息组装。此函数由界面在玩家按下“Guess”按钮或回车时调用。
  - getMasked(): 返回当前谜题的遮盖显示，由内部持有的 CodeSnippet 对象生成，相当于调用snippet.getMasked()。界面更新显示谜题时会用到。
  - getGameInfo(): 虚函数，返回当前游戏状态信息，默认实现提供简单的“已猜次数”字符串，各派生类覆盖此函数提供更详细信息。
  - getDisplayLines(): 虚函数，返回用于界面输出的文字行列表。默认实现已经组合了游戏信息、题号（如需要）、谜题遮盖行、以及输入提示行。Point 模式会 override 它以增加更多提示行。GUI 界面会对默认提示行做一定过滤（如不显示“输入E结束”字样，因为有单独按钮）。
  - isFinished(): 判断玩家是否已解出谜题（CodeSnippet::check()）。返回 true 则游戏胜利完成。
  - Win() / Lose(): 虚函数，返回胜利或失败消息并调用saveStatistics()记录结果。基类提供通用实现，子类可 override 提供附加信息。
  - revealTimes(): 纯虚函数，计算当前猜测应触发的自动揭示次数。各模式必须实现此逻辑。
  - isOver(): 纯虚函数，判断游戏是否达到了失败条件（猜完次数或超时）。积分模式实现为始终false，其余模式需实现具体判定。
  - saveStatistics(bool isWin): 纯虚函数，保存统计数据。由各模式根据胜负或得分实现，将信息传递给 StatisticsRepo。通常在游戏结束时由 Win/Lose 内部调用。
- **各游戏模式类（继承 Game）：**
  - guessLimitedGame: 实现限次数模式。主要函数：
    - start(): 选题并计算maxGuesses上限值；
    - revealTimes(): 返回猜测次数每到5的倍数就揭示1次，否则0次；
    - isOver(): 判断guesses >= maxGuesses；
    - getGameInfo(): 返回字符串“Guesses: X/Y”显示已用/总次数；
    - Win() / Lose(): 返回包含猜测次数信息的胜败消息；
    - saveStatistics(bool): 更新猜次数模式游戏场次和胜场统计。
  - timeAttackGame: 实现限时模式。主要函数：
    - start(): 选题后计算maxTime秒，并记录开始时间；
    - revealTimes(): 根据当前时间和lastRevealTime计算10秒周期内应揭示次数，每经过10秒返回1并累积，更新lastRevealTime；
    - isOver(): 判断是否超过maxTime时间；
    - getGameInfo(): 返回字符串“Time: Ts/Tmaxs”已用/总秒数；
    - Win() / Lose(): 返回包含用时秒数的消息；
    - saveStatistics(bool): 更新限时模式游戏场次和胜场统计。
  - pointGame: 实现积分模式。主要函数：
    - start(): 选题并记录totalNumber总字符用于计分；
    - calcPoint(): 依据已猜字符数和猜测次数计算当前积分，应用惩罚和奖励系数；
    - getGameInfo(): 调用calcPoint()更新积分并返回“Points: P”字符串；
    - getDisplayLines(): 返回积分模式特有的多行提示，包含是否显示ID/模糊的指令说明；
    - revealTimes(): 固定返回0（不自动给提示）；
    - isOver(): 固定返回false（无失败条件，可一直猜）；
    - Win(): 计算最终积分，返回达成积分消息；
    - Lose(): 无失败，直接调用 Win 逻辑；
    - saveStatistics(bool): 调用calcPoint()算出最终积分，记录积分模式场次并累加总积分。
- **AutoGuess 类：**
  - guess(const std::vector&lt;std::string&gt;& mask): 根据当前谜题遮盖状态返回一个猜测建议字符串。实现逻辑详见“自动猜测算法”：顺序扫描预置关键字列表，跳过已出现在遮盖显示中的条目，返回下一个未出现的关键字。如果所有预置选项都试过了则返回随机字符串。
  - random(): 生成长度3的随机字符串，字符从预定义字符集 (字母数字和符号) 中随机选择。该函数被 guess() 用于当关键字列表用尽的情况。
- **UI 类（控制台界面）：**
  - mainloop(): 循环显示主菜单选项并读取用户输入，根据输入调用相应的页面函数（Play->showGamePage()，Rule->showRulePage()等）。用户按E退出循环结束程序。
  - showStartPage()/showRulePage()/showCodePage()/showStatisticsPage(): 分别对应主菜单界面、规则说明、代码库管理、统计信息的显示逻辑。在控制台打印相应内容菜单或信息，并通过读取用户进一步输入处理子功能（如 CodePage 下再提供 List/Read/Add/Remove 选项菜单）。
  - showGamePage(): 控制台模式下开始游戏。提示选择游戏模式（G限次, T限时, P积分），创建相应 Game 对象并调用start()开始。如果题库为空则提示后返回。否则进入循环：输出当前游戏状态和谜题遮盖（调用game->getDisplayLines()获取内容并打印），等待玩家输入猜测或命令：E退出本局、A获取自动猜测、其他字符串为猜测子串。根据不同输入更新游戏状态（调用makeGuess或进行退出处理），直到猜出全部代码（胜利)或满足失败条件/退出。本循环内通过调用 Game 对象的方法实现与图形界面相同的游戏流程。循环结束后删除 Game 对象并保存统计数据。
- **GUI 类（图形界面）：**
  - **界面初始化：** 构造函数中创建主窗口（窗口标题如“CodeWordle”），在适当位置放置 Play、Rule、Code、Stats、Exit 按钮，并为每个按钮设置回调函数（如btnPlay->callback(cb_Play, this)，内部静态函数再调用实例的onPlay()方法）。此外还初始化其它子窗口指针为nullptr以便延迟创建。构造结束后Fl::run()进入事件循环。
  - **主菜单回调：** onPlay()/onRule()/onCode()/onStats()/onExit(): 分别响应用户点击主界面的五个按钮。
    - onPlay(): 弹出模式选择对话框（或直接创建游戏窗口）。在实现中，实际上是直接创建游戏窗口：当玩家点击Play时，程序创建游戏选择窗口或直接默认一种模式？（本实现中可能直接进入默认Limited模式）。由于课程设计要求，此处可能用对话框询问模式然后调用startGame(mode)。在GUI代码中简化处理，默认Limited模式。总之，该函数会隐藏主窗口并显示游戏窗口界面。
    - onRule(): 如果尚未创建规则窗口则创建一个小窗口，其中放置一个不可编辑的文本显示控件加载规则说明字符串，以及一个“Back”返回按钮。显示规则窗口并隐藏主窗口。
    - onCode(): 如果尚未创建代码库窗口则创建，包括 List/Read/Add/Edit/Remove/Back 五个按钮和文本显示区域。显示代码窗口并隐藏主窗口。
    - onStats(): 如果未创建统计窗口则创建，包括一个文本显示框和“Back”按钮，打开时调用统计模块getStatistics()获取内容填入文本框。显示统计窗口并隐藏主窗口。
    - onExit(): 直接退出程序（关闭主窗口）。
  - **返回按钮回调：** onRuleBack()/onCodeBack()/onStatsBack(): 关闭当前规则/代码/统计窗口，返回主菜单（隐藏子窗口，显示主窗口）。
  - **代码库窗口功能回调：**
    - onList(): 列出当前所有代码片段ID。调用repo.list()获取ID列表，将其拼接成多行字符串，在代码窗口的文本显示区域codeBuffer中输出。
    - onRead(): 弹出输入框请求用户输入代码ID，然后读取并显示对应代码内容。内部用fl_input("Enter the code ID to read:", "")获取ID字符串，非空则调用repo.read(id)获取内容文本，若结果为空则表示文件不存在，在文本区域显示“Code not found”，否则将代码内容文本显示出来。
    - onAddEdit(): 打开添加/编辑代码片段窗口。若窗口未创建则动态创建一个模态子窗口，包含“Code ID:”文本框、内容多行输入框，以及 Save 和 Cancel 按钮。每次打开前清空前次输入，显示窗口并将焦点置于ID输入框。玩家填写ID和代码内容后点Save即调用onAddSave(), Cancel则\`onAddCancel()关闭窗口。
    - onRemove(): 弹出输入框请求待删除的代码ID，调用repo.remove(id)删除文件。根据返回值使用fl_message或fl_alert提示“删除成功”或“未找到代码”。
    - onAddSave(): 读取 Add/Edit 窗口中用户填写的ID和内容。如果ID为空则弹出警告fl_alert("Code ID cannot be empty.")要求填写；否则将内容按行分割存入字符串向量，调用repo.add(id, lines)写入文件。若过程中抛出异常（如文件无法写入）则捕获并弹出警告fl_alert(e.what())提示错误。成功则隐藏 Add/Edit 窗口。
    - onAddCancel(): 直接关闭 Add/Edit 子窗口，不保存更改。
  - **游戏窗口及交互回调：**
    - onGuess(): 玩家点击“Guess”按钮或在输入框按回车时触发。函数从输入框读取猜测字符串guess并清空输入框。如果输入为空则不处理；否则调用当前游戏对象的makeGuess(guess)获取反馈消息列表。然后检查游戏状态：若game->isOver()为真，说明这次猜测后已达到失败条件，弹出fl_alert对话框显示失败信息（调用game->Lose()获取消息），随后调用cleanupGame()结束游戏返回主界面；若game->isFinished()为真，说明玩家已猜出全部代码，弹出fl_message显示胜利信息（调用game->Win()），然后同样调用cleanupGame()收尾。若游戏未结束，则调用updateGameDisplay(msg)刷新游戏窗口文本显示区域，将新的谜题遮盖状态和反馈信息显示给玩家，并将焦点重新设置到输入框，方便继续输入下一次猜测。
    - onAuto(): 玩家点击“Auto”按钮触发。若当前无进行中的游戏则不处理；如果有，则调用autoGuesser.guess(game->getMasked())获取建议字符串，将其作为一条提示信息传入updateGameDisplay显示在游戏窗口的文本区域。这样玩家可以看到建议内容，再决定是否采用（需要手动输入该建议进行猜测）。随后重新将光标焦点给输入框。
    - onGiveUp(): 玩家点击“Give Up”触发。该函数用于提前终止当前游戏：如果当前没有游戏进行（game对象为空），则仅关闭游戏窗口、回到主菜单；如果有正在进行的游戏，则弹出fl_alert提示失败信息（调用game->Lose()，在Point模式下虽然没有“失败”，此处相当于结束并显示当前积分），然后调用cleanupGame()结束当前游戏。
    - updateGameDisplay(const std::vector&lt;std::string&gt;& messages): 根据当前游戏状态文本和传入的消息列表刷新游戏显示区域。内部先调用game->getDisplayLines()获取所有应显示的行（包括游戏状态、问题ID、代码遮盖、多行提示等），然后为了图形界面整洁，移除其中针对控制台的输入提示行（删除最后一行以“Enter”开头的提示语句，因为GUI有按钮和输入框，不需要这行文字）。最后将剩余行和传入的额外消息合并成一个字符串，通过 FLTK 文本缓冲区gameBuffer显示出来。每次玩家猜测或获取提示后，本函数都会被调用更新谜题显示与提示信息。
    - cleanupGame(): 清理当前游戏数据并恢复界面状态。删除game对象释放资源，调用stats.saveToFile()保存统计数据，然后隐藏游戏窗口、重新显示主窗口，让用户可以选择进行下一步操作或退出。

通过 GUI 类的一系列回调函数连接，图形界面各按钮的点击事件都能正确地调用底层逻辑，实现了游戏流程的可视化呈现和交互。**主界面 → 游戏窗口 → 结果反馈**的逻辑清晰流畅，用户体验良好。

5.代表性算法举例

本项目在实现过程中设计了多种算法来满足游戏的特殊规则要求，下面选取两个具代表性的算法进行说明：

**5.1 子串模糊匹配算法**

**背景：** 为了增加 CodeWordle 的可玩性，游戏引入了“模糊匹配”机制：当玩家猜的子串与代码片段中某部分非常接近（只差一个字符）时，也给予提示。具体表现是代码显示中会出现#符号，表示该位置有一段内容和玩家猜测几乎匹配。这样的模糊提示有助于玩家发现接近正确的代码元素，即使猜测并非完全正确。

**算法思路：** 在 CodeSnippet 的 guess() 函数中实现，核心步骤如下：

1. **输入校验：** 忽略长度小于3的猜测（直接返回错误标志）。确保比较的子串长度>=3，从而提供足够信息避免过多误报。
2. **逐行遍历：** 对代码的每一行，用滑动窗口提取长度等于猜测串的子串，与玩家的猜测进行比较。
3. **精确匹配检查：** 如果某窗口子串与猜测完全一致，则将该窗口范围内的字符全部标记为已揭示（EXACT_MATCH），计入精确匹配计数。
4. **模糊匹配检查：** 如果允许模糊匹配且当前窗口未精确匹配，则比较猜测串和代码子串的异同：
    - 统计同长度区间内不匹配的字符数failmatch。
    - 统计猜测串中实际字符数count（排除空格，因为代码中可能有空格占位，但猜测一般不会只猜空格）。
    - 若满足 failmatch &lt;= 1 且 count &gt;= 2，则认为这是一个合格的模糊匹配：即除了至多一个字符不同，其余字符均匹配，并且猜测包含至少两个有效字符。
    - 对于合格的模糊匹配窗口，将代码中该窗口范围内**尚未揭示**的字符标记为模糊匹配状态（FUZZY_MATCH）。计入模糊匹配计数。
5. **结果反馈：** 函数返回精确匹配和模糊匹配的次数统计。游戏逻辑会据此生成提示消息，例如“2 matches found, 1 fuzzy match found.”。

通过该算法，玩家的接近猜测不会徒劳无功，而是能获得部分正向反馈。这在代码猜谜游戏中尤为重要，因为代码片段往往比单词更长更复杂，有了模糊提示可以有效降低难度，给予玩家逐步逼近正确答案的机会。

**5.2 自动猜测算法**

**背景：** 为帮助玩家在毫无头绪时继续游戏，CodeWordle 提供“自动猜测”提示功能。当玩家请求自动提示时，系统给出一个建议的代码子串，玩家可以选择尝试猜测该子串。这个算法的难点在于选取一个**既有代表性又尽量有用**的子串来猜。

**算法思路：** 在 AutoGuess 类的 guess(mask) 函数中实现，核心策略是**关键字优先，避免重复**：

1. **关键字列表：** 预先准备一个典型代码片段列表（长度都为3的字符串）。这些包括常用关键字（如"int", "for", "new", "del"）、常见组合（如引用与输出符号"&lt;<\\", "\\"&gt;>"），以及格式或片段（如C库格式化输出"%d "，指针符号"nul"对应“null”，等等）。这些短片段往往在C/C++代码中频繁出现，猜中它们可能快速揭示代码结构。列表按照一定顺序排列（可以是大致频率或任意合理顺序）。
2. **检查已揭示：** AutoGuess 对每次给出的候选子串，会先检查它是否**已经在当前谜题中可见**。具体做法是遍历当前遮盖代码的每一行字符串（mask，每行包含@和已揭示字符），扫描是否存在候选子串（完全匹配，包括#也视作字符占位）。如果某个候选串已经出现在当前显示中了，说明该串对应的内容玩家已基本知道，再提示就没有意义，于是跳过它。
3. **循环选择：** AutoGuess 持有一个索引count，指向下一个待尝试的关键字初始为0。每次调用 guess() 时，从列表keywords\[count\]开始取候选串，按上一步检查是否已出现：
    - 若已出现（visited），则count++，继续检查下一个，直到找到未出现的候选或列表末尾。
    - 若找到未出现的关键字，则返回它作为本次提示，并将count增1（下次将从下一个关键字继续）。
    - 如果count已达列表末尾（表示所有预设关键字都用过或都已在屏幕上出现过），则改用随机猜测，通过random()生成三个字符，返回该随机串作为提示。
4. **避免重复：** 由于每次返回后都会递增count，同一局游戏中不会重复给出相同的关键字提示。如果列表循环完每项仍没猜出代码，那么AutoGuess后续就只能提供随机串，相当于尽力但未猜到。这种设计保证前几次提示最有参考价值。

通过该算法，玩家不会一开始就陷入完全随机猜测，而是能获得一些典型方向的引导。例如大多数代码都会有类型声明int、控制结构for/if等，AutoGuess 很可能在前几次就提供这些，使玩家逐步揭开谜底。总的来说，自动猜测算法充分利用了对编程语言特征的了解，帮助玩家在卡住时重获思路。

6.运行环境

本项目使用 C++ 编写，图形界面基于 FLTK 库，仅在 Windows 上完成测试。

如果仅使用 UI 类，可以注释掉 GUI 类，使用 g++ main.cpp -o main -O2 -Wall 编译即可。

要使用 GUI 类，需要确保安装 FLTK ([www.fltk.org](www.fltk.org))，版本推荐为1.4.3。然后可以安装 MinGW ([www.mingw-w64.org](http://www.mingw-w64.org/)) ，确保选择安装 gcc、g++ 和 make 组件。

编译时打开 MinGW 终端，cd 到FLTK 源代码目录，然后运行命令 ./configure 和 mingw32-make 构建 FLTK。成功后运行 g++ main.cpp -o main -O2 -Wall $(fltk-config --cxxflags --ldflags) 可完成编译。

7.不足

页面缺少直观的高亮或颜色区分，游戏难度仍偏高，自动提示有效性有限，统计数据分析不足，跨平台没有测试（仅在 Windows 上测试）。
